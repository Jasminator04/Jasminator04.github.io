<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CS61B_pro0 | Jas' Blog</title><meta name=keywords content><meta name=description content="2048游戏
要求是完成Model.java中的四个方法
public static boolean emptySpaceExists(Board b)
这个方法的描述如下：
This method should return true if any of the tiles in the given board are null.
其实就是如果棋盘上还有空位（某个格子 null），就要返回true；如果棋盘已经满了，就返回false，游戏也就结束了。
也就是将整个棋盘遍历，查找是否还有null格子。
根据提示，需要使用Board 类的 tile(int col, int row) and size() 方法。
详细代码如下：
public int size() {
        return values.length;
}

public Tile tile(int col, int row) {
        return vtile(col, row, viewPerspective);
}
这里的values是一个二维数组，所以size()方法也就是返回棋盘的边长。
tile方法就是获得坐标(col,row)在棋盘上的映射。（该方法返回的是一个tile对象）
运用双重for循环遍历行列以此来达到遍历棋盘的目的，再使用tile方法获得映射，来验证是否为null。这里需要注意的是，我一开始写的是t.value()==null，但是Tile.value() 的返回类型是 int（比如 2、4、8…），永远不可能是null，判断一个 Tile 是否为null，要判断 t 本身是不是 null，而不是 t.value() 。
总体代码如下：
public static boolean emptySpaceExists(Board b) {
        // TODO: Fill in this function.
        for (int col=0;col< b.size();col++){
            for(int row=0;row< b.size();row++){
                Tile t=b.tile(col,row);
                if(t==null){
                    return true;
                }
            }
        }
        return false;
    }
测试通过。"><meta name=author content="Jasmine"><link rel=canonical href=https://Jasminator04.github.io/posts/cs61b_pro0/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://Jasminator04.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://Jasminator04.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://Jasminator04.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://Jasminator04.github.io/apple-touch-icon.png><link rel=mask-icon href=https://Jasminator04.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://Jasminator04.github.io/posts/cs61b_pro0/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://Jasminator04.github.io/posts/cs61b_pro0/"><meta property="og:site_name" content="Jas' Blog"><meta property="og:title" content="CS61B_pro0"><meta property="og:description" content="2048游戏
要求是完成Model.java中的四个方法
public static boolean emptySpaceExists(Board b) 这个方法的描述如下：
This method should return true if any of the tiles in the given board are null.
其实就是如果棋盘上还有空位（某个格子 null），就要返回true；如果棋盘已经满了，就返回false，游戏也就结束了。
也就是将整个棋盘遍历，查找是否还有null格子。
根据提示，需要使用Board 类的 tile(int col, int row) and size() 方法。
详细代码如下：
public int size() { return values.length; } public Tile tile(int col, int row) { return vtile(col, row, viewPerspective); } 这里的values是一个二维数组，所以size()方法也就是返回棋盘的边长。
tile方法就是获得坐标(col,row)在棋盘上的映射。（该方法返回的是一个tile对象）
运用双重for循环遍历行列以此来达到遍历棋盘的目的，再使用tile方法获得映射，来验证是否为null。这里需要注意的是，我一开始写的是t.value()==null，但是Tile.value() 的返回类型是 int（比如 2、4、8…），永远不可能是null，判断一个 Tile 是否为null，要判断 t 本身是不是 null，而不是 t.value() 。
总体代码如下：
public static boolean emptySpaceExists(Board b) { // TODO: Fill in this function. for (int col=0;col< b.size();col++){ for(int row=0;row< b.size();row++){ Tile t=b.tile(col,row); if(t==null){ return true; } } } return false; } 测试通过。"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-09T12:05:27+08:00"><meta property="article:modified_time" content="2025-09-09T12:05:27+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="CS61B_pro0"><meta name=twitter:description content="2048游戏
要求是完成Model.java中的四个方法
public static boolean emptySpaceExists(Board b)
这个方法的描述如下：
This method should return true if any of the tiles in the given board are null.
其实就是如果棋盘上还有空位（某个格子 null），就要返回true；如果棋盘已经满了，就返回false，游戏也就结束了。
也就是将整个棋盘遍历，查找是否还有null格子。
根据提示，需要使用Board 类的 tile(int col, int row) and size() 方法。
详细代码如下：
public int size() {
        return values.length;
}

public Tile tile(int col, int row) {
        return vtile(col, row, viewPerspective);
}
这里的values是一个二维数组，所以size()方法也就是返回棋盘的边长。
tile方法就是获得坐标(col,row)在棋盘上的映射。（该方法返回的是一个tile对象）
运用双重for循环遍历行列以此来达到遍历棋盘的目的，再使用tile方法获得映射，来验证是否为null。这里需要注意的是，我一开始写的是t.value()==null，但是Tile.value() 的返回类型是 int（比如 2、4、8…），永远不可能是null，判断一个 Tile 是否为null，要判断 t 本身是不是 null，而不是 t.value() 。
总体代码如下：
public static boolean emptySpaceExists(Board b) {
        // TODO: Fill in this function.
        for (int col=0;col< b.size();col++){
            for(int row=0;row< b.size();row++){
                Tile t=b.tile(col,row);
                if(t==null){
                    return true;
                }
            }
        }
        return false;
    }
测试通过。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://Jasminator04.github.io/posts/"},{"@type":"ListItem","position":2,"name":"CS61B_pro0","item":"https://Jasminator04.github.io/posts/cs61b_pro0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CS61B_pro0","name":"CS61B_pro0","description":"2048游戏\n要求是完成Model.java中的四个方法\npublic static boolean emptySpaceExists(Board b) 这个方法的描述如下：\nThis method should return true if any of the tiles in the given board are null.\n其实就是如果棋盘上还有空位（某个格子 null），就要返回true；如果棋盘已经满了，就返回false，游戏也就结束了。\n也就是将整个棋盘遍历，查找是否还有null格子。\n根据提示，需要使用Board 类的 tile(int col, int row) and size() 方法。\n详细代码如下：\npublic int size() { return values.length; } public Tile tile(int col, int row) { return vtile(col, row, viewPerspective); } 这里的values是一个二维数组，所以size()方法也就是返回棋盘的边长。\ntile方法就是获得坐标(col,row)在棋盘上的映射。（该方法返回的是一个tile对象）\n运用双重for循环遍历行列以此来达到遍历棋盘的目的，再使用tile方法获得映射，来验证是否为null。这里需要注意的是，我一开始写的是t.value()==null，但是Tile.value() 的返回类型是 int（比如 2、4、8…），永远不可能是null，判断一个 Tile 是否为null，要判断 t 本身是不是 null，而不是 t.value() 。\n总体代码如下：\npublic static boolean emptySpaceExists(Board b) { // TODO: Fill in this function. for (int col=0;col\u0026lt; b.size();col++){ for(int row=0;row\u0026lt; b.size();row++){ Tile t=b.tile(col,row); if(t==null){ return true; } } } return false; } 测试通过。\n","keywords":[],"articleBody":"2048游戏\n要求是完成Model.java中的四个方法\npublic static boolean emptySpaceExists(Board b) 这个方法的描述如下：\nThis method should return true if any of the tiles in the given board are null.\n其实就是如果棋盘上还有空位（某个格子 null），就要返回true；如果棋盘已经满了，就返回false，游戏也就结束了。\n也就是将整个棋盘遍历，查找是否还有null格子。\n根据提示，需要使用Board 类的 tile(int col, int row) and size() 方法。\n详细代码如下：\npublic int size() { return values.length; } public Tile tile(int col, int row) { return vtile(col, row, viewPerspective); } 这里的values是一个二维数组，所以size()方法也就是返回棋盘的边长。\ntile方法就是获得坐标(col,row)在棋盘上的映射。（该方法返回的是一个tile对象）\n运用双重for循环遍历行列以此来达到遍历棋盘的目的，再使用tile方法获得映射，来验证是否为null。这里需要注意的是，我一开始写的是t.value()==null，但是Tile.value() 的返回类型是 int（比如 2、4、8…），永远不可能是null，判断一个 Tile 是否为null，要判断 t 本身是不是 null，而不是 t.value() 。\n总体代码如下：\npublic static boolean emptySpaceExists(Board b) { // TODO: Fill in this function. for (int col=0;col\u003c b.size();col++){ for(int row=0;row\u003c b.size();row++){ Tile t=b.tile(col,row); if(t==null){ return true; } } } return false; } 测试通过。\npublic static boolean maxTileExists(Board b) 这一个方法就是判断数字是否有达到2048(即MAX_PIECE)，有即返回true，无则返回false。特别提示了要使用MAX_PIECE而非2048。\n同样还是遍历，在不为null的情况下查询value值进行判断，有上一个方法的基础后，这一个方法会比较简单。\npublic static boolean maxTileExists(Board b) { // TODO: Fill in this function. for (int col=0;col\u003c b.size();col++){ for(int row=0;row\u003c b.size();row++){ Tile t=b.tile(col,row); if(t!=null){ if(t.value()==MAX_PIECE){ return true; } } } } return false; } public static boolean atLeastOneMoveExists(Board b) 如果有任何有效的移动，它应该返回 true。\n有效的移动有以下两种：\n1.板上至少有一个空白区域。\n2.有两个相邻的图块具有相同的值。\n第一个条件很好判断，直接调用第一个完成的方法emptySpaceExists()就可以了。\n第二个条件稍微复杂一点，这里的(0,0)坐标对应的是左下角的元素，将棋盘中的每一个元素与右边和上边的元素值作比较可以覆盖所有元素，没有遗漏。\npublic static boolean atLeastOneMoveExists(Board b) { // TODO: Fill in this function. if (emptySpaceExists(b)){ return true; } for(int col=0;col\u003cb.size();col++){ for(int row=0;row\u003cb.size();row++){ Tile t=b.tile(col,row); if(col+1\u003cb.size()){ Tile right=b.tile(col+1,row); if(t!=null \u0026\u0026 right!=null \u0026\u0026 t.value()==right.value()){ return true; } } if(row+1\u003cb.size()){ Tile up=b.tile(col,row+1); if(t!=null \u0026\u0026 up!=null \u0026\u0026 t.value()==up.value()){ return true; } } } } return false; } tilt public boolean tilt(Side side) 设视角为 side（统一当“往上推”）。 对每一列执行“目标行 + 从上到下放砖 + 单次合并 + 目标行逐步下移”的固定套路。 过程中如有搬家或合并 → 记 changed = true；合并时加分。 恢复视角为 NORTH；返回 changed。 首先设定视角side，运用for循环来遍历每一列，在每一列中设定顶行为targetRow。\n同时设定上一回合的合并行数lastMergedRow为-1（先是不存在的）\n然后将row从targetRow的下一行开始向下遍历。有两个对象：target和t，target则为目标，t为目前选中的元素。\n有三个规则：\n对每个非空 t，执行“放砖三规则”（按这个顺序判断）\n规则 1：目标位是空的 把 t 放到 targetRow。 修改changed为true 规则 2：目标位非空、值相等、且该目标位本回合尚未合并 在 targetRow 合并（值翻倍，分数 += 新值）。 这一步一定算变化（changed = true）。 这一回合已经合并过了，修改lastMergedRow=targetRow;再让targetRow-1。 规则 3：其他情况（目标位非空但值不等，或该目标位刚合并过） 先把 targetRow 下移一格（去占用下面那格）。 把 t 放到新的 targetRow； 修改changed=true 再将视角调回NORTH\npublic boolean tilt(Side side) { boolean changed; changed = false; // TODO: Modify this.board (and perhaps this.score) to account // for the tilt to the Side SIDE. If the board changed, set the // changed local variable to true. board.setViewingPerspective(side); for(int col=0;col\u003cboard.size();col++){ int targetRow= board.size()-1; int lastMergedRow = -1; for(int row= board.size()-2;row\u003e=0;row--){ Tile target=board.tile(col,targetRow); Tile t=board.tile(col,row); if(t==null){ continue; }else{ if(target==null){ board.move(col, targetRow, t); changed = true; }else if(target!=null \u0026\u0026 target.value()==t.value() \u0026\u0026 lastMergedRow!=targetRow){ int mergedValue=target.value()*2; board.move(col,targetRow,t); score+=mergedValue; changed=true; lastMergedRow=targetRow; targetRow--; }else{ targetRow-=1; board.move(col, targetRow, t); changed = true; } } } } board.setViewingPerspective(Side.NORTH); checkGameOver(); if (changed) { setChanged(); } return changed; } ","wordCount":"363","inLanguage":"en","datePublished":"2025-09-09T12:05:27+08:00","dateModified":"2025-09-09T12:05:27+08:00","author":{"@type":"Person","name":"Jasmine"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://Jasminator04.github.io/posts/cs61b_pro0/"},"publisher":{"@type":"Organization","name":"Jas' Blog","logo":{"@type":"ImageObject","url":"https://Jasminator04.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://Jasminator04.github.io/ accesskey=h title="Jas' Blog (Alt + H)">Jas' Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">CS61B_pro0</h1><div class=post-meta><span title='2025-09-09 12:05:27 +0800 CST'>September 9, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Jasmine</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#public-static-boolean-emptyspaceexistsboard-b aria-label="public static boolean emptySpaceExists(Board b)">public static boolean emptySpaceExists(Board b)</a></li><li><a href=#public-static-boolean-maxtileexistsboard-b aria-label="public static boolean maxTileExists(Board b)">public static boolean maxTileExists(Board b)</a></li><li><a href=#public-static-boolean-atleastonemoveexistsboard-b aria-label="public static boolean atLeastOneMoveExists(Board b)">public static boolean atLeastOneMoveExists(Board b)</a></li><li><a href=#tilt aria-label=tilt>tilt</a><ul><li><a href=#public-boolean-tiltside-side aria-label="public boolean tilt(Side side)">public boolean tilt(Side side)</a><ul><li><a href=#%e8%a7%84%e5%88%99-1%e7%9b%ae%e6%a0%87%e4%bd%8d%e6%98%af%e7%a9%ba%e7%9a%84 aria-label="规则 1：目标位是空的">规则 1：目标位是空的</a></li><li><a href=#%e8%a7%84%e5%88%99-2%e7%9b%ae%e6%a0%87%e4%bd%8d%e9%9d%9e%e7%a9%ba%e5%80%bc%e7%9b%b8%e7%ad%89%e4%b8%94%e8%af%a5%e7%9b%ae%e6%a0%87%e4%bd%8d%e6%9c%ac%e5%9b%9e%e5%90%88%e5%b0%9a%e6%9c%aa%e5%90%88%e5%b9%b6 aria-label="规则 2：目标位非空、值相等、且该目标位本回合尚未合并">规则 2：目标位非空、值相等、且该目标位本回合尚未合并</a></li><li><a href=#%e8%a7%84%e5%88%99-3%e5%85%b6%e4%bb%96%e6%83%85%e5%86%b5%e7%9b%ae%e6%a0%87%e4%bd%8d%e9%9d%9e%e7%a9%ba%e4%bd%86%e5%80%bc%e4%b8%8d%e7%ad%89%e6%88%96%e8%af%a5%e7%9b%ae%e6%a0%87%e4%bd%8d%e5%88%9a%e5%90%88%e5%b9%b6%e8%bf%87 aria-label="规则 3：其他情况（目标位非空但值不等，或该目标位刚合并过）">规则 3：其他情况（目标位非空但值不等，或该目标位刚合并过）</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><p>2048游戏</p><p>要求是完成Model.java中的四个方法</p><h1 id=public-static-boolean-emptyspaceexistsboard-b><strong>public static boolean emptySpaceExists(Board b)</strong><a hidden class=anchor aria-hidden=true href=#public-static-boolean-emptyspaceexistsboard-b>#</a></h1><p>这个方法的描述如下：</p><p>This method should return true if any of the tiles in the given board are null.</p><p>其实就是如果棋盘上还有空位（某个格子 <code>null</code>），就要返回true；如果棋盘已经满了，就返回false，游戏也就结束了。</p><p>也就是将整个棋盘遍历，查找是否还有null格子。</p><p>根据提示，需要使用<code>Board</code> 类的 <code>tile(int col, int row)</code> and <code>size()</code> 方法。</p><p>详细代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>size</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> values.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> Tile <span style=color:#a6e22e>tile</span>(<span style=color:#66d9ef>int</span> col, <span style=color:#66d9ef>int</span> row) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> vtile(col, row, viewPerspective);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里的values是一个二维数组，所以size()方法也就是返回棋盘的边长。</p><p>tile方法就是获得坐标(col,row)在棋盘上的映射。（该方法返回的是一个tile对象）</p><p>运用双重for循环遍历行列以此来达到遍历棋盘的目的，再使用tile方法获得映射，来验证是否为null。这里需要注意的是，我一开始写的是t.value()==null，但是<code>Tile.value()</code> 的返回类型是 <strong><code>int</code></strong>（比如 2、4、8…），永远不可能是null，判断一个 <code>Tile</code> 是否为null，要判断 <code>t</code> 本身是不是 <code>null</code>，而不是 <code>t.value()</code> 。</p><p>总体代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>emptySpaceExists</span>(Board b) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// TODO: Fill in this function.</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> col<span style=color:#f92672>=</span>0;col<span style=color:#f92672>&lt;</span> b.<span style=color:#a6e22e>size</span>();col<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> row<span style=color:#f92672>=</span>0;row<span style=color:#f92672>&lt;</span> b.<span style=color:#a6e22e>size</span>();row<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>                Tile t<span style=color:#f92672>=</span>b.<span style=color:#a6e22e>tile</span>(col,row);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(t<span style=color:#f92672>==</span><span style=color:#66d9ef>null</span>){
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>测试通过。</p><h1 id=public-static-boolean-maxtileexistsboard-b><strong>public static boolean maxTileExists(Board b)</strong><a hidden class=anchor aria-hidden=true href=#public-static-boolean-maxtileexistsboard-b>#</a></h1><p>这一个方法就是判断数字是否有达到2048(即MAX_PIECE)，有即返回true，无则返回false。特别提示了要使用MAX_PIECE而非2048。</p><p>同样还是遍历，在不为null的情况下查询value值进行判断，有上一个方法的基础后，这一个方法会比较简单。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>maxTileExists</span>(Board b) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// TODO: Fill in this function.</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> col<span style=color:#f92672>=</span>0;col<span style=color:#f92672>&lt;</span> b.<span style=color:#a6e22e>size</span>();col<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> row<span style=color:#f92672>=</span>0;row<span style=color:#f92672>&lt;</span> b.<span style=color:#a6e22e>size</span>();row<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>                Tile t<span style=color:#f92672>=</span>b.<span style=color:#a6e22e>tile</span>(col,row);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(t<span style=color:#f92672>!=</span><span style=color:#66d9ef>null</span>){
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span>(t.<span style=color:#a6e22e>value</span>()<span style=color:#f92672>==</span>MAX_PIECE){
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h1 id=public-static-boolean-atleastonemoveexistsboard-b><strong>public static boolean atLeastOneMoveExists(Board b)</strong><a hidden class=anchor aria-hidden=true href=#public-static-boolean-atleastonemoveexistsboard-b>#</a></h1><p>如果有任何有效的移动，它应该返回 true。</p><p>有效的移动有以下两种：</p><p>1.板上至少有一个空白区域。</p><p>2.有两个相邻的图块具有相同的值。</p><p>第一个条件很好判断，直接调用第一个完成的方法emptySpaceExists()就可以了。</p><p>第二个条件稍微复杂一点，这里的(0,0)坐标对应的是左下角的元素，将棋盘中的每一个元素与右边和上边的元素值作比较可以覆盖所有元素，没有遗漏。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>atLeastOneMoveExists</span>(Board b) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// TODO: Fill in this function.</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (emptySpaceExists(b)){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> col<span style=color:#f92672>=</span>0;col<span style=color:#f92672>&lt;</span>b.<span style=color:#a6e22e>size</span>();col<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> row<span style=color:#f92672>=</span>0;row<span style=color:#f92672>&lt;</span>b.<span style=color:#a6e22e>size</span>();row<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>                Tile t<span style=color:#f92672>=</span>b.<span style=color:#a6e22e>tile</span>(col,row);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(col<span style=color:#f92672>+</span>1<span style=color:#f92672>&lt;</span>b.<span style=color:#a6e22e>size</span>()){
</span></span><span style=display:flex><span>                    Tile right<span style=color:#f92672>=</span>b.<span style=color:#a6e22e>tile</span>(col<span style=color:#f92672>+</span>1,row);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span>(t<span style=color:#f92672>!=</span><span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> right<span style=color:#f92672>!=</span><span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> t.<span style=color:#a6e22e>value</span>()<span style=color:#f92672>==</span>right.<span style=color:#a6e22e>value</span>()){
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(row<span style=color:#f92672>+</span>1<span style=color:#f92672>&lt;</span>b.<span style=color:#a6e22e>size</span>()){
</span></span><span style=display:flex><span>                    Tile up<span style=color:#f92672>=</span>b.<span style=color:#a6e22e>tile</span>(col,row<span style=color:#f92672>+</span>1);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span>(t<span style=color:#f92672>!=</span><span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> up<span style=color:#f92672>!=</span><span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> t.<span style=color:#a6e22e>value</span>()<span style=color:#f92672>==</span>up.<span style=color:#a6e22e>value</span>()){
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h1 id=tilt>tilt<a hidden class=anchor aria-hidden=true href=#tilt>#</a></h1><h2 id=public-boolean-tiltside-side><strong>public boolean tilt(Side side)</strong><a hidden class=anchor aria-hidden=true href=#public-boolean-tiltside-side>#</a></h2><ul><li>设视角为 <code>side</code>（统一当“往上推”）。</li><li><strong>对每一列</strong>执行“目标行 + 从上到下放砖 + 单次合并 + 目标行逐步下移”的固定套路。</li><li>过程中如有搬家或合并 → 记 <code>changed = true</code>；合并时加分。</li><li>恢复视角为 NORTH；返回 <code>changed</code>。</li></ul><p>首先设定视角side，运用for循环来遍历每一列，在每一列中设定顶行为targetRow。</p><p>同时设定上一回合的合并行数lastMergedRow为-1（先是不存在的）</p><p>然后将row从targetRow的下一行开始向下遍历。有两个对象：target和t，target则为目标，t为目前选中的元素。</p><p>有三个规则：</p><p>对每个非空 t，执行“放砖三规则”（按这个顺序判断）</p><h3 id=规则-1目标位是空的>规则 1：目标位是空的<a hidden class=anchor aria-hidden=true href=#规则-1目标位是空的>#</a></h3><ul><li>把 <strong>t 放到 targetRow</strong>。</li><li>修改changed为true</li></ul><h3 id=规则-2目标位非空值相等且该目标位本回合尚未合并>规则 2：目标位非空、值相等、且该目标位本回合<strong>尚未合并</strong><a hidden class=anchor aria-hidden=true href=#规则-2目标位非空值相等且该目标位本回合尚未合并>#</a></h3><ul><li><strong>在 targetRow 合并</strong>（值翻倍，分数 += 新值）。</li><li>这一步一定算变化（changed = true）。</li><li>这一回合已经合并过了，修改lastMergedRow=targetRow;再让targetRow-1。</li></ul><h3 id=规则-3其他情况目标位非空但值不等或该目标位刚合并过>规则 3：其他情况（目标位非空但值不等，或该目标位刚合并过）<a hidden class=anchor aria-hidden=true href=#规则-3其他情况目标位非空但值不等或该目标位刚合并过>#</a></h3><ul><li>先把 <strong>targetRow 下移一格</strong>（去占用下面那格）。</li><li>把 <strong>t 放到新的 targetRow</strong>；</li><li>修改changed=true</li></ul><p>再将视角调回NORTH</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>tilt</span>(Side side) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>boolean</span> changed;
</span></span><span style=display:flex><span>        changed <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// TODO: Modify this.board (and perhaps this.score) to account</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// for the tilt to the Side SIDE. If the board changed, set the</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// changed local variable to true.</span>
</span></span><span style=display:flex><span>        board.<span style=color:#a6e22e>setViewingPerspective</span>(side);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> col<span style=color:#f92672>=</span>0;col<span style=color:#f92672>&lt;</span>board.<span style=color:#a6e22e>size</span>();col<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> targetRow<span style=color:#f92672>=</span> board.<span style=color:#a6e22e>size</span>()<span style=color:#f92672>-</span>1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> lastMergedRow <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>1;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> row<span style=color:#f92672>=</span> board.<span style=color:#a6e22e>size</span>()<span style=color:#f92672>-</span>2;row<span style=color:#f92672>&gt;=</span>0;row<span style=color:#f92672>--</span>){
</span></span><span style=display:flex><span>                Tile target<span style=color:#f92672>=</span>board.<span style=color:#a6e22e>tile</span>(col,targetRow);
</span></span><span style=display:flex><span>                Tile t<span style=color:#f92672>=</span>board.<span style=color:#a6e22e>tile</span>(col,row);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(t<span style=color:#f92672>==</span><span style=color:#66d9ef>null</span>){
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }<span style=color:#66d9ef>else</span>{
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span>(target<span style=color:#f92672>==</span><span style=color:#66d9ef>null</span>){
</span></span><span style=display:flex><span>                        board.<span style=color:#a6e22e>move</span>(col, targetRow, t);
</span></span><span style=display:flex><span>                        changed <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                    }<span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(target<span style=color:#f92672>!=</span><span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> target.<span style=color:#a6e22e>value</span>()<span style=color:#f92672>==</span>t.<span style=color:#a6e22e>value</span>() <span style=color:#f92672>&amp;&amp;</span>  lastMergedRow<span style=color:#f92672>!=</span>targetRow){
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>int</span> mergedValue<span style=color:#f92672>=</span>target.<span style=color:#a6e22e>value</span>()<span style=color:#f92672>*</span>2;
</span></span><span style=display:flex><span>                        board.<span style=color:#a6e22e>move</span>(col,targetRow,t);
</span></span><span style=display:flex><span>                        score<span style=color:#f92672>+=</span>mergedValue;
</span></span><span style=display:flex><span>                        changed<span style=color:#f92672>=</span><span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                        lastMergedRow<span style=color:#f92672>=</span>targetRow;
</span></span><span style=display:flex><span>                        targetRow<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>                    }<span style=color:#66d9ef>else</span>{
</span></span><span style=display:flex><span>                        targetRow<span style=color:#f92672>-=</span>1;
</span></span><span style=display:flex><span>                        board.<span style=color:#a6e22e>move</span>(col, targetRow, t);
</span></span><span style=display:flex><span>                        changed <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        board.<span style=color:#a6e22e>setViewingPerspective</span>(Side.<span style=color:#a6e22e>NORTH</span>);
</span></span><span style=display:flex><span>        checkGameOver();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (changed) {
</span></span><span style=display:flex><span>            setChanged();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> changed;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://Jasminator04.github.io/>Jas' Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>